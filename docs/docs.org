# ###############################################################################
#+TITLE: *Wykorzystanie ontologii w językach programowania do programowania rozproszonego.*
#+AUTHOR: Kajetan Rzepecki
#+DATE: \small{EIS 2014} \\* \\* \today
#
#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [12pt, a4paper]
#+LaTeX_HEADER: \usepackage[margin=2cm]{geometry}
#+LaTeX_HEADER: \usepackage{minted}
#+LaTeX_HEADER: \usepackage [polish]{babel}
#+OPTIONS: tags:nil toc:nil
# ###################

#+latex: \thispagestyle{empty}
#+latex: \vfill \vfill \vfill
#+latex: \pagebreak

* Wstęp
Celem projektu jest zbadanie możliwości oraz opłacalności wykorzystania ontologii w celu reprezentacji wiedzy w języku programowania przeznaczonego do programowania rozproszonego, zorientowanego zdarzeniowo.

Projektowany język ma umożliwiać łatwe rozproszenie aplikacji na wiele heterogenicznych maszyn cechujących się różnymi architekturami, dostępnymi peryferiami sprzętowymi oraz aplikacjami. Dodatkowo dużą wagę będzie przywiązywał do asynchronicznej obsługi zdarzeń zachodzących w systemie - wykorzystany zostanie mechanizm obsługi zdarzeń (Complex Event Processing, CEP) bazujący na Systemach Regułowych (RBS).

W celu ułatwienia pracy w tak zróżnicowanym środowisku niezbędna będzie jego semantyzacja i udostępnienie odkrytej wiedzy w przystępny sposób. Dodatkowym wymogiem jest łatwa integracja z obecnym w języku mechanizmem obsługi zdarzeń, uzupełnienie jego funkcjonalności i umożliwienie nie tylko reagowania na pojawienie się nowej wiedzy o systemie, ale również refleksji nad dotychczas odkrytą wiedzą.

* Analiza problemu
Projektowany język zostanie wyposażony w system modułowy, którego zadaniem będzie abstrakcja pewnych funkcjonalności dostępnych na danej platformie sprzętowej bądź programowej, składający się z kilku kluczowych elementów przedstawionych na poniższym diagramie wraz z głównymi relacjami w jakich występują:

#+BEGIN_CENTER
#+attr_latex: :width 0.6\textwidth
[[file:./img/ms.pdf]]
#+END_CENTER

#+LaTeX: \noindent
Elementy te pełnią następujące funkcje:

- *protokoły* - zapewniają interfejs oraz kontrakty (typy, testy, pre/post-conditions), są przechodnie (wszystko co definiuje odpowiedni interfejs jednocześnie implementuje protokół),
- *moduły* - zapewniają konkretną implementację protokołów (definicje funkcji, dodatkowe kontrakty i testy),
- *funkcje* - stanowią najmniejsze bloki budulcowe programów,
- *procesy* - stanowią kontekst uruchomieniowy jednego z wielu wątków programu (powiązane bloki pamięci, kolejkę asynchronicznie odebranych wiadomości, kontynuacje aktualnie uruchamianej funkcji oraz inne metadane),
- *jednostki* - wiążą statyczne moduły z dynamicznymi procesami zapewniając stan pomiędzy wywołaniami funkcji pewnego protokołu.

Głównymi zadaniami powyższego systemu modułowego jest zapewnienie dystrybucji i redundancji dostępnych funkcjonalności oraz ułatwienie tworzenia dynamicznych aplikacji:

- *dystrybucja* - odwołania do procesów wykorzystują dodatkowy poziom pośredni w postaci *identyfikatora procesu*, dzięki czemu możliwe jest odwoływanie się do procesów działających na innej maszynie,
- *redundancja* - w jednej chwili w systemie (tj. na różnych maszynach połączonych w klaster) może istnieć wiele modułów implementujących te same protokoły na różne sposoby,
- *dynamizm* - aplikacje zbudowane będą z jednostek, które w dowolnej chwili mogą być uruchamiane, zatrzymywane lub przenoszone na inne maszyny.

#+LaTeX: \noindent
Dystrybucja, redundancja i dynamizm tworzą potrzebę rozróżniania dostępnych funkcjonalności nie tylko po ich nazwach lub interfejsach, jak ma to miejsce w większości obecnie stosowanych języków programowania, ale także po innych, arbitralnych i zależnych od konkretnej funkcjonalności cechach, takich jak złożoność obliczeniowa jej implementacji, dokładność odczytu danych sensorycznych, czy obciążenie sieci, w której działa jedna z maszyn podłączonych do klastra.

** Przykład zastosowania systemu modułowego
Poniżej przedstawiono prosty przykład zastosowania opisanego powyżej systemu modułowego. Przykład definiuje prosty protokół =gps= pozwalający na pobieranie aktualnej lokacji (funkcja =get-location=) z maksymalną dozwoloną tolerancją (=tolerance=):

#+BEGIN_SRC scheme
(define-protocol gps
  (declare (get-location pid)
    (@ tolerance 0.01)))
#+END_SRC

#+LaTeX: \noindent
...oraz dwie jednostki =basic-gps= oraz =vendor-gps= go implementujące:

#+BEGIN_SRC scheme
(define-module (basic-gps)
  (provide gps)
  (provide unit)

  ;; Unit specific
  (define (start _) nil)

  (define (stop reason) 'ok)

  (define (loop curr-location)
    (loop
     (receive
         (`(get-location ,from) (send! from curr-location))
         (after 1000 (update-location)))))

  ;; GPS specific
  (define (get-location pid)
    (send! `(get-location (self)))
    (receive))

  (define (update-location)
    ;; read & return GPS location
    ))
#+END_SRC

#+LaTeX: \noindent
...które różnią się jedynie toleracją funkcji odpowiedzialnej za odczyt danych sensorycznych:

#+BEGIN_SRC scheme
(define-module (vendor-gps)
  (provide gps)
  (provide unit)

  ;; ... details same as basic-gps

  (declare (get-location pid)
    (@ tolerance 0.0001))

  (define (update-location)
    ;; read & return better GPS location
    ))
#+END_SRC

#+LaTeX: \noindent
Przykładowy scenariusz wykorzystania powyższych jednostek mógłby przebiegać następująco:

- Maszyna =N= posiada wiedzę o działających jednostkach w pozostałych maszynach podłączonych do klastra.
- Na maszynie =N= startuje nowa jednostka =U= wymagająca funkcji lokalizacyjnej.
- Jednostka =U= odkrywa wiedzę o istnieniu dwóch jednostek dostarczających funkcje lokalizacji: =basic-gps= oraz =vendor-gps=, z których =vendor-gps= działa na zdalnej maszynie.
- Jednostka =U= rozstrzyga o wyborze odpowiedniej jednostki na podstawie =tolerance= dostarczanych funkcji lokalizacji oraz fizycznych lokacji jednostek, wybieracjąc =vendor-gps=.
- Jednostka =U= deklaruje regułę, iż w przypadku zatrzymania =vendor-gps= powinna się przełączyć na =basic-gps=.
- Maszyna =P=, na której działa =vendor-gps= ginie w pożarze domu starców.
- Maszyna =N= nie otrzymawszy odpowiedzi od maszyny =P= na pakiet /heartbeat/ uznaje ją za niefunkcjonalną i inwaliduje całą wiedzę z nią związaną.
- Jednostka =U= otrzymawszy informację o dezintegracji =vendor-gps= automatycznie przełącza się na =basic-gps=.
- System działa długo i szczęśliwie.

** Wykorzystanie wiedzy w języku
Projektowany język programowania będzie posiadał zintegrowany mechanizm obsługi zdarzeń, zaimplementowany jako system regułowy, korzystający z bazy faktów reprezentujących wiedzę o działającej aplikacji.

Faktem może być dowolna =n=-krotka przynajmniej dwóch wartości, która zostaje dodana do systemu przez procedurę =assert!= (stała asercja), lub =signal!= (tymczasowa sygnalizacja):

#+BEGIN_EXAMPLE
(predicate subject object-a object-b ...)
(is-a X unit)
(provides X unit-protocol)
(unit-started X)
#+END_EXAMPLE

#+LaTeX: \noindent
Fakty te mogą reprezentować strukturę dostępnych modułów, jednostek lub protokołów, a także zachodzenie pewnych zdarzeń, takich jak wystartowanie jednostki, załadowanie modułu, lub podłączenie nowej maszyny do klastra.

Aby wykorzystać tak odkrywaną wiedzę o strukturze i działaniu aplikacji należy zdefiniować reguły za pomocą konstrukcji =whenever=:

#+BEGIN_SRC scheme
(whenever pattern
          action)

(whenever (and (unit-started ?x)
               (provides ?x ?some-functionality))
          (start-using ?some-functionality))
#+END_SRC

Mechanizm taki pozwala korzystać ze zdobytej wiedzy w sposób *proaktywny* - zdefiniowane reguły zostają uruchomione (wykonane zostają związane z nimi akcje) w momencie zaistnienia odpowiedniej sytuacji - w momencie dodania do bazy wszystkich faktów wymaganych do spełnienia lewej strony reguły.

#+LaTeX: \noindent
Nie jest jednak możliwe korzystanie ze zgromadzonej wiedzy w sposób *reaktywny* - nie można tworzyć dowolnych zapytań do bazy faktów - utrudniając implementację wielu pożądanych mechanizmów, takich jak odkrywanie usług (*service discovery*), czy dopasowywanie usług (*service matching*).

W związku z powyższym, niemożliwe jest zrealizowanie trzeciego punktu przytoczonego w poprzedniej sekcji przypadku użycia dotyczącego odkrywania wiedzy o strukturze systemu przez nowo-wystartowaną jednostkę - ponieważ fakty tworzone przy startowaniu jednostek =basic-gps= oraz =vendor-gps= zostały już przetworzone prez mechanizm, nowo-wystartowana jednostka nie ma możliwości ponownego ich odkrycia i wykorzystania do własnych celów.

Problemem do rozwiązania jest zatem *umożliwienie refleksji nad bazą powiązanych ze sobą faktów w sposób wydajny i wygodny w użytkowaniu* - na przykład wykorzystując język zapytań podobny do języków zapytań relacyjnych baz danych z rodziny SQL - przy jednoczesnym zachowaniu kompatybilności z mechanizmem obsługi zdarzeń i uzupełnieniu jego funkcjonalności o dodatkowe operacje na bazie faktów.

** Podobne rozwiązania
- Przegląd obecnych metod SOA - statyczne formaty definicji usług, brak elastyczności w odkrywaniu usług,
- Call by Meaning - nieadekwatna wydajność.

* Szkic rozwiązania
** Porównanie różnych podejść
- Predefiniowane formaty opisu usług (np. WSDL)
- Systemy Regułowe - problem późnego startu/restartu usług
- Ontologie/bazy faktów
** Podejście semantyczne
- Wstępny plan ontologii
- Lista pojęć i zależności między nimi

* Prototyp rozwiązania
[[https://github.com/Idorobots/facts][Link do repozytorium na GitHub.]]

** Ontologia Systemu Modułowego

** Przykłady wykorzystania ontologii
- Automatyczna inferencja dostępnej klasy obiektów
- Zapytania SPARQL

* Analiza proponowanego rozwiązania
** Wnioski

* Bibliografia
- Hesam Samimi, Chris Deaton, Yoshiki Ohshima, Alessandro Warth, and Todd Millstein, /Call by Meaning/, In Proceedings of the 2014 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming & Software (Onward! 2014), ACM, New York, NY, USA, 11-28, http://doi.acm.org/10.1145/2661136.266115
